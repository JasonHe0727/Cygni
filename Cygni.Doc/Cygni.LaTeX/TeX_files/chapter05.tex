\chapter{Classes}
The data and functions within a class are known as the class's members.
The following example displays the usage of the cygni class.

\begin{lstlisting}
class position{
	def __init(nx, ny){
		this.x = nx
		this.y = ny
	}

	def move(nx, ny){
		this.x = nx
		this.y = ny
	}

	def __toStr(){
		printf("({0}, {1})", this.x, this.y)
	}

}
p1 = position(10,20)
print(p1)
p1.move(35, 47)
print(p1)
\end{lstlisting}

\section{Data Members}
Data members are those members that contain data for the class.


\section{Function Members}
Functions members are functions defined within the class. The "function members" includes not only functions, but also constructors, operators, indexers, etc. An example is as followings:

\subsection{Constructors}
The default constructor is a non-arg function, which will only initialize the already-exist fields. You can overload the constructor by writing a function which is named as "\_\_INIT".

\begin{lstlisting}
class MyClass {
	def __init([arguments]) {
		# initialzze the class
	}
}
\end{lstlisting}

In the example "position", the constructor of class "position" initialize two fields "x" and "y".

\subsection{Implementation Inheritance}
If you want to declare that a class derives from another class, use the following syntax:

\begin{lstlisting}
class myDerivedClass: myBaseClass {
	# functions and data members here
}
\end{lstlisting} 

The Cygni class does not support multiple inheritance. Namely, a class can only inherit from one class.

\begin{lstlisting}
class person {
	def __init(name, age) {
		this.name = name
		this.age = age
	}

	def say() {
		print('I am a person!')
	}
}

class employee : person {
	def __init(name, age, salary) {
		this.name = name
		this.age = age
		this.salary = salary
	}

	def say() {
		print('I am an employee!')
	}
}
\end{lstlisting}


\subsection{Hiding Function Members}
If a function with the same name is declared in both base and derived classs, the function in the derived class will hide the one in the base class.

There are some built-in functions that can be overwrited.
\begin{itemize}
	\item \_\_init: Constructor for the class. The default constructor is a non-arg constructor.
	\item \_\_toStr: Output the class instance as a string.
	\item \_\_add: override '+' operator.
	\item \_\_sub: override '-' operator.
	\item \_\_mul: override '*' operator.
	\item \_\_div: override '/' operator.
	\item \_\_mod: override '\%' operator.
	\item \_\_pow: override '\^' operator.
	\item \_\_unaryPlus: override '+' operator.
	\item \_\_unaryMinus: override '-' operator.
	\item \_\_cmp: return a integer to indicate the comparision result. This function will override the $'>', '<', '>=', '<='$ operators.
	\item \_\_equals: return a bool value to indicate whether two objects are the same. The function will over load the '==','!=' operators.
	% \item \_\_INDEXER\_\_: This function takes a list as indexes, and return an element.
\end{itemize}
\subsection{Example: vector}
\begin{lstlisting}
class vector {
	def __init(values) {
		this.values = values
	}

	def __add(other) {
		if this.values.count != other.values.count {
			throw ("vector length error")
		}
		result = [] 
		for i = 0, this.values.count {
			result.append(this.values[i] + other.values[i])
		}
		return vector(result)
	}

	def __unaryMinus() {
		result = [] 
		for i = 0, this.values.count {
			result.append(-this.values[i])
		}
		return vector(result)
	}

	def __sub(other) {
		return this.__add(other.__unaryMinus())
	}

	def __mul(other) {
		if this.values.count != other.values.count {
			throw ("vector length error")
		}
		sum = 0
		for i = 0, this.value.count {
			sum = sum + this.values[i] * other.values[i]
		}
		return sum
	}

	def __equals(other) {
		if this.values.count != other.values.count {
			return false
		}
		for i = 0, this.values.count {
			if this.values[i] != other.values[i] {
				return false
			}
		}
		return true
	}
		
	def __toStr() {
		return strcat("vector(", toString(this.values), ")")
	}
}
\end{lstlisting}
