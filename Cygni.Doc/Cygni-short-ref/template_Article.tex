\documentclass[]{article}
\usepackage{listings}
%opening
\title{Cygni 1.0\\ A Short Reference}
\author{He Yanjie}

\begin{document}

\maketitle

\begin{abstract}

\end{abstract}

\section{What is Cygni?}
Cygni is a script programming language implemented in C\#. It is easy to use, has neat grammar and can interacts with C\#. It is convenient to wrap C\# classes as Cygni class, namely the Cygni libraries are based on the C\# class libraries.

Cygni is designed by me. I spent a lot of spare time on it, and I love it very much. I hope you will like it too!

\section{Core Language}
\subsection{Reserved words}
\begin{itemize}
	\item and
	\item or
	\item not
	\item true
	\item false
	\item nil
	\item if
	\item else
	\item elif
	\item while
	\item for
	\item in
	\item def
	\item lambda
	\item class
	\item var
	\item break
	\item continue
	\item return	
\end{itemize}
\subsection{Reserved Symbols}
\begin{itemize}
	\item Add:+
	\item Subtract:- 
	\item Multiply:*
	\item Divide:/
	\item Integer Divide: //
	\item Modulo:\%
	\item Power: \^{}
	\item Concatenate: \&
	\item assign: =
	\item Equals:==
	\item Not Equals: !=
	\item Greater than: $>$
	\item Less than: $<$
	\item Greater than or Equals: $>=$
	\item Less than or Equals: $<=$
	\item Goes to: $=>$
	\item Parentheses: (\ )
	\item Brackets: [ \  ]
	\item Braces: \{ \ \}
	\item Colon: :
	\item Comma: ,
\end{itemize}
\subsection{Identifiers}
The first character of identifiers should be underline or letters, the rest can be underlines, letters or numbers.
Note that the identifiers should not be the same as the reserved words.

\subsection{Comments}
Line comment start with \#.

\subsection{Strings}
String should be enclosed by '' or "". If there is symbol \@ at the start of string, then the escaped characters in the string will be ignored, and the ' or " in the string shoule be written twice.

\subsection{Types}
Variables in Cygni don't have type. Only the values have.
\begin{itemize}
	\item integer
	\item number
	\item boolean: true or false
	\item string
	\item list: lists contain elements from various types.
	\item dictionary: key-value pairs
	\item function
	\item native function: wrapper for C\# native functions
	\item tuple
	\item range
	\item struct
	\item class
	\item userdata: wrapper for C\# native classes.
	\item nil
\end{itemize}

\subsection{Control Statements}
\subsubsection{If}
'if' statement can have one or more braches.
\begin{lstlisting}
if condition {
	# Do something
} else {
	# Do something
}

if condition1 {
	# Branch 1
} elif condition2 {
	# Branch 2
} else {
	# Branch 3
}
\end{lstlisting}

\subsubsection{For}
'for' statement iterates a collection. You may use range syntax to declare a iterable collection. The iterator shouldn't be changed during the iteration.

\begin{lstlisting}
for i = start: end {
	# Do something
}

for i = start: end: step {
	# Do something
}

for item in collection {
	# Do something
}
\end{lstlisting}

\paragraph{While}
'while' statement will keep running unless the condition is false.

\begin{lstlisting}
while condition {
	# Do something
}
\end{lstlisting}

\subsubsection{Break, Continue, Return}

break, return exit the loop. continue stays in the loop.

\subsection{Range Constructor}

\begin{lstlisting}
start: end
start: end: step
\end{lstlisting}

\subsection{List Constructor}
\begin{lstlisting}
[item1, item2, ...]
\end{lstlisting}


\subsection{Dictionary Constructor}
Note that dictionary only takes values of integer, boolean, string as keys.
\begin{lstlisting}
{key1: value1, key2:  value2, ...}
\end{lstlisting}

\subsection{Function Definition}
'def' statement declares a function with a name.
'lambda' statement declares an anonymous function, which contains a statement or a block.

\begin{lstlisting}
def FunctionName (arg1, arg2, ...) {
	# Do something	
}

a = lambda(arg1, arg2, ...) => # Expression

a = lambda(arg1, arg2,...) => {
	# Do something
}
\end{lstlisting}

\subsection{Invoke Function}
\begin{lstlisting}
f(arg1, arg2, ...)
\end{lstlisting}

\subsection{Tuple Constructor}
\begin{lstlisting}
a = tuple(10, 20)
unpack x, y = a
\end{lstlisting}

\subsection{Struct Constructor}
\begin{lstlisting}
a = struct('key1', value1, 'key2', value2, ...)
\end{lstlisting}

\subsection{Class Definition}
\begin{lstlisting}
class MyClass {
	# body
}

class DerivedClass: MyClass {
	# body
}
\end{lstlisting}

\subsubsection{Reserved Fields}
\begin{itemize}
	\item \_\_init\_\_
	\item \_\_add\_\_
	\item \_\_sub\_\_
	\item \_\_mul\_\_
	\item \_\_div\_\_
	\item \_\_mod\_\_
	\item \_\_pow\_\_
	\item \_\_unp\_\_
	\item \_\_unm\_\_
	\item \_\_cmp\_\_
	\item \_\_eq\_\_
	\item \_\_getItem\_\_
	\item \_\_setItem\_\_
	\item \_\_toStr\_\_
\end{itemize}


\section{Basic Library}
\subsection{Executing}
\begin{itemize}
	\item source(fileName [,encoding])

	description: execute a script file.

	\item require(fileName [,encoding])
	
	description: execute a script file and return it as a module.

	\item import(fileName [,encoding])

	description: execute a script file in the current global scope.
\end{itemize}

\subsection{Console Output and input}

\begin{itemize}
	\item print(args) print arguments in the console, separated by tab.

	\item printf(content, args) print format string in the console. The arguments can be indexed by \{0\},\{1\}... in the string.

	\item input([content]) write the content in the console and waiting for user to input. The content can be omitted.
\end{itemize}


\subsection{Conversion}
\begin{itemize}
	\item int(a) convert certain value into integer.

	\item number(a) convert certain value into number.

	\item str(a) convert certain value into string.

	\item list(a) convert an iterable object into list.

\end{itemize}


\section{The Math Library}
To simplify, all the arguments for the functions in math library only takes number as parameters. If the argument is an integer, it will be converted into number.

\begin{itemize}
	\item math.sqrt(x)
	\item math.abs(x)
	\item math.log(x [,base])
	\item math.log10(x)
	\item math.max(args)
	\item math.min(args)
	\item math.exp(x)
	\item math.sign(x)
	\item math.sin(x)
	\item math.cos(x)
	\item math.tan(x)
	\item math.asin(x)
	\item math.acos(x)
	\item math.atan(x)
	\item math.sinh(x)
	\item math.cosh(x)
	\item math.tanh(x)
	\item math.ceiling(x)
	\item math.floor(x)
	\item math.round(x)
	\item math.truncate(x)
\end{itemize}




\end{document}
